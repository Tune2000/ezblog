/*
SQLyog Ultimate v11.25 (64 bit)
MySQL - 8.0.26 : Database - ez_blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`ez_blog` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `ez_blog`;

/*Table structure for table `ez_article` */

DROP TABLE IF EXISTS `ez_article`;

CREATE TABLE `ez_article` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(256) DEFAULT NULL COMMENT '标题',
  `content` longtext COMMENT '文章内容',
  `summary` varchar(1024) DEFAULT NULL COMMENT '文章摘要',
  `category_id` bigint DEFAULT NULL COMMENT '所属分类id',
  `thumbnail` varchar(256) DEFAULT NULL COMMENT '缩略图',
  `is_top` char(1) DEFAULT '0' COMMENT '是否置顶（0否，1是）',
  `status` char(1) DEFAULT '1' COMMENT '状态（0已发布，1草稿）',
  `view_count` bigint DEFAULT '0' COMMENT '访问量',
  `is_comment` char(1) DEFAULT '1' COMMENT '是否允许评论 1是，0否',
  `create_by` bigint DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文章表';

/*Data for the table `ez_article` */

insert  into `ez_article`(`id`,`title`,`content`,`summary`,`category_id`,`thumbnail`,`is_top`,`status`,`view_count`,`is_comment`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (9,'Spring入门01','## 1.Spring简介\n	 Spring是一个开源框架，它由[Rod Johnson]([https://baike.baidu.com/item/Rod](https://baike.baidu.com/item/Rod) Johnson)创建。它是为了解决企业应用开发的复杂性而创建的。\n	 目前是JavaEE开发的灵魂框架。他可以简化JavaEE开发，可以非常方便整合其他框架，无侵入的进行功能增强。\n	 Spring的核心就是 控制反转(IoC)和面向切面(AOP) 。\n## 2.IOC控制反转\n### 2.1 概念\n	控制反转，之前对象的控制权在类手上，现在反转后到了Spring手上。\n### 2.2 入门案例\n#### ①导入依赖\n导入SpringIOC相关依赖\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n```\n#### ②编写配置文件\n在resources目录下创建applicationContext.xml文件，文件名可以任意取。但是建议叫applicationContext。\n内容如下：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!--\n        classs:配置类的全类名\n        id:配置一个唯一标识\n    -->\n    <bean class=\"com.wxx.dao.impl.StudentDaoImpl\" id=\"studentDao\"  >\n    </bean>\n\n</beans>\n```\n#### ③创建容器从容器中获取对象并测试\n```java\n    public static void main(String[] args) {\n\n//        1.获取StudentDaoImpl对象\n        //创建Spring容器，指定要读取的配置文件路径\n        ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //从容器中获取对象\n        StudentDao studentDao = (StudentDao) app.getBean(\"studentDao\");\n        //调用对象的方法进行测试\n        System.out.println(studentDao.getStudentById(1));\n    }\n```\n### 2.3 Bean的常用属性配置\n#### 2.3.1 id\n	bean的唯一标识，同一个Spring容器中不允许重复\n#### 2.3.2 class\n	全类名，用于反射创建对象\n#### 2.3.3 scope\n	scope主要有两个值：singleton和prototype\n	如果设置为singleton则一个容器中只会有这个一个bean对象。默认容器创建的时候就会创建该对象。\n	如果设置为prototype则一个容器中会有多个该bean对象。每次调用getBean方法获取时都会创建一个新对象。\n## 3.DI依赖注入\n	依赖注入可以理解成IoC的一种应用场景，反转的是对象间依赖关系维护权。\n### 3.1 set方法注入\n在要注入属性的bean标签中进行配置。前提是该类有提供属性对应的set方法。\n```java\npackage com.wxx.domain;\n\npublic class Student {\n\n    private String name;\n    private int id;\n    private int age;\n\n    private Dog dog;\n\n    public Dog getDog() {\n        return dog;\n    }\n\n    public void setDog(Dog dog) {\n        this.dog = dog;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name=\'\" + name + \'\\\'\' +\n                \", id=\" + id +\n                \", age=\" + age +\n                \'}\';\n    }\n\n    public Student() {\n\n    }\n\n    public Student(String name, int id, int age) {\n        this.name = name;\n        this.id = id;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n```xml\n    <bean class=\"com.wxx.domain.Dog\" id=\"dog\">\n        <property name=\"name\" value=\"小白\"></property>\n        <property name=\"age\" value=\"6\"></property>\n    </bean>\n\n    <bean class=\"com.wxx.domain.Student\" id=\"student\" >\n        <!--\n            name属性用来指定要设置哪个属性\n            value属性用来设置要设置的值\n            ref属性用来给引用类型的属性设置值，可以写上Spring容器中bean的id\n        -->\n        <property name=\"name\" value=\"东南枝\"></property>\n        <property name=\"age\" value=\"20\"></property>\n        <property name=\"id\" value=\"1\"></property>\n        <property name=\"dog\" ref=\"dog\"></property>\n    </bean>\n```\n### 3.2 有参构造注入\n在要注入属性的bean标签中进行配置。前提是该类有提供对应的有参构造。\n```java\npublic class Student {\n\n    private String name;\n    private int id;\n    private int age;\n\n    private Dog dog;\n\n    public Student(String name, int id, int age, Dog dog) {\n        this.name = name;\n        this.id = id;\n        this.age = age;\n        this.dog = dog;\n    }\n    //.....省略其他\n}\n```\n```xml\n    <!--使用有参构造进行注入-->\n    <bean class=\"com.wxx.domain.Student\" id=\"student2\" >\n        <constructor-arg name=\"name\" value=\"自挂东南枝\"></constructor-arg>\n        <constructor-arg name=\"age\" value=\"20\"></constructor-arg>\n        <constructor-arg name=\"id\" value=\"30\"></constructor-arg>\n        <constructor-arg name=\"dog\" ref=\"dog\"></constructor-arg>\n    </bean>\n```\n### 3.3 复杂类型属性注入\n实体类如下：\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n    private int age;\n    private String name;\n    private Phone phone;\n    private List<String> list;\n    private List<Phone> phones;\n    private Set<String> set;\n    private Map<String, Phone> map;\n    private int[] arr;\n    private Properties properties;\n}\n```\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Phone {\n    private double price;\n    private String name;\n    private String password;\n    private String path;\n\n}\n```\n配置如下：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean class=\"com.wxx.domain.Phone\" id=\"phone\">\n        <property name=\"price\" value=\"3999\"></property>\n        <property name=\"name\" value=\"黑米\"></property>\n        <property name=\"password\" value=\"123\"></property>\n        <property name=\"path\" value=\"qqqq\"></property>\n    </bean>\n    \n    <bean class=\"com.wxx.domain.User\" id=\"user\">\n        <property name=\"age\" value=\"10\"></property>\n        <property name=\"name\" value=\"大队长\"></property>\n        <property name=\"phone\" ref=\"phone\"></property>\n        <property name=\"list\">\n            <list>\n                <value>王昭君</value>\n                <value>西施</value>\n            </list>\n        </property>\n\n        <property name=\"phones\">\n            <list>\n                <ref bean=\"phone\"></ref>\n            </list>\n        </property>\n\n        <property name=\"set\">\n            <set>\n                <value>setEle1</value>\n                <value>setEle2</value>\n            </set>\n        </property>\n\n        <property name=\"map\">\n            <map>\n                <entry key=\"k1\" value-ref=\"phone\"></entry>\n                <entry key=\"k2\" value-ref=\"phone\"></entry>\n            </map>\n        </property>\n\n        <property name=\"arr\">\n            <array>\n                <value>10</value>\n                <value>11</value>\n            </array>\n        </property>\n\n        <property name=\"properties\">\n            <props>\n                <prop key=\"k1\">v1</prop>\n                <prop key=\"k2\">v2</prop>\n            </props>\n        </property>\n    </bean>\n</beans>\n```\n## 4.Lombok\n### ①导入依赖\n```xml\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.16</version>\n        </dependency>\n```\n### ②增加注解\n```java\n@Data //根据属性生成set，get方法\n@NoArgsConstructor //生成空参构造\n@AllArgsConstructor //生成全参构造\npublic class Phone {\n    private double price;\n    private String name;\n    private String password;\n    private String path;\n\n}\n```\n## 5.SPEL\nSpring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。\n	我们可以再配置文件中使用SPEL表达式。写法如下:\n```xml\n        <property name=\"age\" value=\"#{20}\"/>\n        <property name=\"car\" value=\"#{car}\"/>\n```\n	注意：SPEL需要写到value属性中，不能写到ref属性。\n## 6.配置文件\n### 6.1 读取properties文件\n	我们可以让Spring读取properties文件中的key/value，然后使用其中的值。\n#### ①设置读取properties\n在Spring配置文件中加入如下标签：指定要读取的文件的路径。\n```xml\n<context:property-placeholder location=\"classpath:filename.properties\">\n```\n其中的classpath表示类加载路径下。\n在我们运行后生成target文件夹，原本resource里面的文件会在target里面的类加载目录classes文件下\n我们也会用到如下写法：classpath:**.properties  其中的_  _ 表示文件名任意。\n**注意：context命名空间的引入是否正确**\n#### ②使用配置文件中的值\n在我们需要使用的时候可以使用${key}来表示具体的值。注意要再value属性中使用才可以。例如：\n```xml\n<property name=\"propertyName\" value=\"${key}\"/>\n```\n### 6.2 引入Spring配置文件\n	我们可以在主的配置文件中通过import标签的resource属性，引入其他的xml配置文件\n```xml\n<import resource=\"classpath:applicationContext-book.xml\"/>\n```\n## 7. 低频知识点\n### 7.1 bean的配置\n#### 7.1.1 name属性\n	我们可以用name属性来给bean取名。例如：\n```xml\n    <bean class=\"com.alibaba.druid.pool.DruidDataSource\" id=\"dataSource\" name=\"dataSource2,dataSource3\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n```\n	获取的时候就可以使用这个名字来获取了\n```java\n    public static void main(String[] args) {\n\n        ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        DruidDataSource dataSource = (DruidDataSource) app.getBean(\"dataSource3\");\n        System.out.println(dataSource);\n\n    }\n```\n#### 7.1.2 lazy-init\n	可以控制bean的创建时间，如果设置为true就是在第一次获取该对象的时候才去创建。\n```xml\n    <bean class=\"com.alibaba.druid.pool.DruidDataSource\" lazy-init=\"true\"  id=\"dataSource\" name=\"dataSource2,dataSource3\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n```\n#### 7.1.3 init-method\n	可以用来设置初始化方法，设置完后容器创建完对象就会自动帮我们调用对应的方法。\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Student {\n\n    private String name;\n    private int id;\n    private int age;\n	//初始化方法\n    public void init(){\n        System.out.println(\"对学生对象进行初始化操作\");\n    }\n\n}\n```\n```xml\n<bean class=\"com.wxx.domain.Student\" id=\"student\" init-method=\"init\"></bean>\n```\n**注意：配置的初始化方法只能是空参的。**\n#### 7.1.4 destroy-method\n	可以用来设置销毁之前调用的方法，设置完后容器销毁对象前就会自动帮我们调用对应的方法。\n```xml\n    <bean class=\"com.wxx.domain.Student\" id=\"student\"  destroy-method=\"close\"></bean>\n```\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Student {\n\n    private String name;\n    private int id;\n    private int age;\n\n    public void init(){\n        System.out.println(\"对学生对象进行初始化操作\");\n    }\n\n    public void close(){\n        System.out.println(\"对象销毁之前调用，用于释放资源\");\n    }\n}\n```\n**注意：配置的方法只能是空参的。**\n#### 7.1.5 factory-bean&factory-method\n	当我们需要让Spring容器使用工厂类来创建对象放入Spring容器的时候可以使用factory-bean和factory-method属性。\n##### 7.1.5.1 配置实例工厂创建对象\n配置文件中进行配置\n```xml\n    <!--创建实例工厂-->\n    <bean class=\"com.wxx.factory.CarFactory\" id=\"carFactory\"></bean>\n    <!--使用实例工厂创建Car放入容器-->\n    <!--factory-bean 用来指定使用哪个工厂对象-->\n    <!--factory-method 用来指定使用哪个工厂方法-->\n    <bean factory-bean=\"carFactory\" factory-method=\"getCar\" id=\"car\"></bean>\n```\n创建容器获取对象测试\n```java\n        ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //获取car对象\n        Car c = (Car) app.getBean(\"car\");\n        System.out.println(c);\n```\n##### 7.1.5.2 配置静态工厂创建对象\n配置文件中进行配置\n```xml\n    <!--使用静态工厂创建Car放入容器-->\n    <bean class=\"com.wxx.factory.CarStaticFactory\" factory-method=\"getCar\" id=\"car2\"></bean>\n```\n创建容器获取对象测试\n```java\n        ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //获取car对象\n        Car c = (Car) app.getBean(\"car2\");\n        System.out.println(c);\n```\n','Spring入门博客共有4篇，分别是Spring入门01-04',16,'rzpy18v9b.hn-bkt.clouddn.com/2023/11/23/2fc123b4869645cabec862999779665c.png','1','0',1,'0',1,'2023-11-23 01:26:33',1,'2023-11-23 01:26:33',0),(10,'Spring入门02','## 1.注解开发\n	为了简化配置，Spring支持使用注解代替xml配置。\n## 2.Spring常用注解\n### 2.0 注解开发准备工作\n	如果要使用注解开发必须要开启组件扫描，这样加了注解的类才会被识别出来。Spring才能去解析其中的注解。\n```xml\n<!--启动组件扫描，指定对应扫描的包路径，该包及其子包下所有的类都会被扫描，加载包含指定注解的类-->\n<context:component-scan base-package=\"com.wxx\"/>\n```\n### 2.1 IOC相关注解\n#### 2.1.1 @Component,@Controller,@Service  ,@Repository\n	上述4个注解都是加到类上的。\n	他们都可以起到类似bean标签的作用。可以把加了该注解类的对象放入Spring容器中。\n	实际再使用时选择任意一个都可以。但是后3个注解是语义化注解。\n	如果是Service类要求使用@Service。\n	如果是Dao类要求使用@Repository  \n	如果是Controllerl类(SpringMVC中会学习到)要求使用@Controller  \n	如果是其他类可以使用@Component  \n例如：\n配置文件如下：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n<!--启动组件扫描，指定对应扫描的包路径，该包及其子包下所有的类都会被扫描，加载包含指定注解的类-->\n    <context:component-scan base-package=\"com.wxx\"></context:component-scan>\n\n</beans>\n```\n类如下：\n```java\n@Repository(\"userDao\")\npublic class UserDaoImpl implements UserDao {\n\n    public void show() {\n        System.out.println(\"查询数据库，展示查询到的数据\");\n    }\n}\n```\n```java\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Component(\"phone\")\npublic class Phone {\n    private double price;\n    private String name;\n    private String password;\n    private String path;\n\n}\n```\n```java\n@Service(\"userService\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class UserServiceImpl implements UserService {\n\n\n    private UserDao userDao;\n\n    private int num;\n\n    private String str;\n\n\n    public void show() {\n        userDao.show();\n    }\n}\n```\n测试类如下：\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        //创建容器\n        ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //获取对象\n        UserDao userDao = (UserDao) app.getBean(\"userDao\");\n        Phone phone = (Phone) app.getBean(\"phone\");\n        UserService userService = (UserService) app.getBean(\"userService\");\n        System.out.println(phone);\n        System.out.println(userService);\n        System.out.println(userDao);\n    }\n}\n```\n### 2.2 DI相关注解\n	如果一个bean已经放入Spring容器中了。那么我们可以使用下列注解实现属性注入，让Spring容器帮我们完成属性的赋值。\n#### 2.2.1 @Value  \n	主要用于String,Integer等可以直接赋值的属性注入。不依赖setter方法，支持SpEL表达式。\n例如：\n```java\n@Service(\"userService\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class UserServiceImpl implements UserService {\n    private UserDao userDao;\n    @Value(\"199\")\n    private int num;\n    @Value(\"wxx\")\n    private String str;\n    @Value(\"#{19+3}\")\n    private Integer age;\n\n\n    public void show() {\n        userDao.show();\n    }\n}\n```\n#### 2.2.2 @AutoWired  \n	Spring会给加了该注解的属性自动注入数据类型相同的对象。\n例如：\n```java\n@Service(\"userService\")\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private UserDao userDao;\n\n    @Value(\"199\")\n    private int num;\n    @Value(\"wxx\")\n    private String str;\n\n    @Value(\"#{19+3}\")\n    private Integer age;\n\n\n    public void show() {\n        userDao.show();\n    }\n}\n```\n	**required属性代表这个属性是否是必须的，默认值为true。如果是true的话Spring容器中如果找不到相同类型的对象完成属性注入就会出现异常。**\n#### 2.2.3 @Qualifier  \n	如果相同类型的bean在容器中有多个时，单独使用@AutoWired就不能满足要求，这时候可以再加上@Qualifier来指定bean的名字从容器中获取bean注入。\n例如：\n```java\n@Repository(\"dao\")\npublic class UserDaoImpl implements UserDao {\n\n    public void show() {\n        System.out.println(\"查询数据库，展示查询到的数据\");\n    }\n}\n```\n```java\n@Repository(\"userDao2\")\npublic class UserDaoImpl2 implements UserDao {\n\n    public void show() {\n        System.out.println(\"查询数据库，展示查询到的数据\");\n    }\n}\n```\n从容器中获取bean注入：\n```java\n    @Autowired\n    @Qualifier(\"userDao2\")\n    private UserDao userDao;\n```\n**注意：该注解不能单独使用。单独使用没有作用**\n### 2.3 xml配置文件相关注解\n#### @Configuration  \n	标注在类上，表示当前类是一个配置类。我们可以用注解类来完全替换掉xml配置文件。\n	注意：如果使用配置类替换了xml配置，spring容器要使用：AnnotationConfigApplicationContext\n例如：\n```java\n@Configuration\npublic class ApplicationConfig {\n}\n```\n#### @ComponentScan  \n	可以用来代替context:component-scan标签来配置组件扫描。\n	basePackages属性来指定要扫描的包。\n	注意要加在配置类上。\n例如：\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.wxx\")//指定要扫描的包\npublic class ApplicationConfig {\n}\n```\n#### @Bean \n	可以用来代替bean标签，主要用于第三方类的注入。\n	使用：定义一个方法，在方法中创建对应的对象并且作为返回值返回。然后在方法上加上@Bean注解，注解的value属性来设置bean的名称。\n例如：\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.wxx\")\npublic class ApplicationConfig {\n\n    @Bean(\"dataSource\")\n    public DruidDataSource getDataSource(){\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        druidDataSource.setUsername(\"root\");\n        druidDataSource.setUrl(\"jdbc:mysql://localhost:3306/mybatis_db\");\n        druidDataSource.setPassword(\"root\");\n        return druidDataSource;\n    }\n\n}\n```\n**注意事项：如果同一种类型的对象在容器中只有一个，我们可以不设置bean的名称。**\n具体写法如下：\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.wxx\")\npublic class ApplicationConfig {\n\n    @Bean\n    public DruidDataSource getDataSource(){\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        druidDataSource.setUsername(\"root\");\n        druidDataSource.setUrl(\"jdbc:mysql://localhost:3306/mybatis_db\");\n        druidDataSource.setPassword(\"root\");\n        return druidDataSource;\n    }\n\n}\n```\n获取方式如下：\n```java\n    public static void main(String[] args) {\n        //创建注解容器\n        AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext(ApplicationConfig.class);\n		//根据对应类的字节码对象获取\n        DataSource bean = app.getBean(DataSource.class);\n        System.out.println(userService);\n    }\n```\n#### @PropertySource  \n	可以用来代替context:property-placeholder，让Spring读取指定的properties文件。然后可以使用@Value来获取读取到的值。\n	**使用：在配置类上加@PropertySource注解，注解的value属性来设置properties文件的路径。**\n	**然后在配置类中定义成员变量。在成员变量上使用@Value注解来获取读到的值并给对应的成员变量赋值。**\n例如：\njdbc.properties文件内容如下：\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/mybatis_db\njdbc.username=root\njdbc.password=root\n```\n读取文件并且获取值\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.wxx\")\n@PropertySource(\"jdbc.properties\")\npublic class ApplicationConfig {\n\n    @Value(\"${jdbc.driver}\")\n    private String driverClassName;\n    @Value(\"${jdbc.url}\")\n    private String url;\n    @Value(\"${jdbc.username}\")\n    private String username;\n    @Value(\"${jdbc.password}\")\n    private String password;\n\n\n    @Bean\n    public DruidDataSource getDataSource(){\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setDriverClassName(driverClassName);\n        druidDataSource.setUsername(username);\n        druidDataSource.setUrl(url);\n        druidDataSource.setPassword(password);\n        return druidDataSource;\n    }\n\n}\n```\n**注意事项：使用@Value获取读到的properties文件中的值时使用的是${key},而不是#{key}。**\n## 3.如何选择\n①SSM\n		自己项目中的类的IOC和DI都使用注解，对第三方jar包中的类，配置组件扫描时使用xml进行配置。\n②SpringBoot\n		纯注解开发\n','Spring入门博客共有4篇，分别是Spring入门01-04',16,'rzpy18v9b.hn-bkt.clouddn.com/2023/11/23/758d2244820d4929aeca929719919c31.png','1','0',0,'0',1,'2023-11-23 01:28:56',NULL,'2023-11-23 01:29:10',0),(11,'Spring入门03','## 1. AOP\n### 1.1 概念\n	 AOP为Aspect Oriented Programming的缩写，意为：面向切面编程。他是一种可以在不修改原来的核心代码的情况下给程序动态统一进行增强的一种技术。\n	**SpringAOP:  批量对Spring容器中bean的方法做增强，并且这种增强不会与原来方法中的代码耦合。**\n### 1.2 快速入门\n#### 1.2.1 需求\n	要求让_08_SpringAOP模块中service包下所有类的所有方法在调用前都输出：方法被调用了。\n#### 1.2.2 准备工作\n##### ①添加依赖\n需要添加SpringIOC相关依赖和AOP相关依赖。\n```xml\n        <!--SpringIOC相关依赖-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n        <!--AOP相关依赖-->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n```\n##### ②相关bean要注入容器中\n开启组件扫描\n```xml\n<context:component-scan base-package=\"com.wxx\"></context:component-scan>\n```\n加@Service注解\n```java\n@Service\npublic class PhoneService {\n\n    public void deleteAll(){\n        System.out.println(\"PhoneService中deleteAll的核心代码\");\n    }\n}\n```\n```java\n@Service\npublic class UserService {\n\n\n    public void deleteAll(){\n        System.out.println(\"UserService中deleteAll的核心代码\");\n    }\n}\n```\n#### 1.2.3 实现AOP\n##### ①开启AOP注解支持\n使用**aop:aspectj-autoproxy**标签\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--开启组件扫描-->\n    <context:component-scan base-package=\"com.wxx\"></context:component-scan>\n    <!--开启aop注解支持-->\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\n</beans>\n```\n##### ②创建切面类\n创建一个类，在类上加上@Component和@Aspect，@Component让这个类对象自动放到容器中，@Aspect告诉容器这个类是一个切面类。\n使用@Pointcut注解来指定要被增强的方法\n使用@Before注解来给我们的增强代码所在的方法进行标识，并且指定了增强代码是在被增强方法执行之前执行的。\n```java\n@Component\n@Aspect\npublic class MyAspect {\n\n//    用Pointcut注解中的属性来指定对哪些方法进行增强\n    @Pointcut(\"execution(* com.sangeng.service.*.*(..))\")\n    public void pt(){}\n\n    /*\n        用@Before注解来指定该方法中是增强的代码，并且是在被增强方法执行前执行的\n        @Before的属性写上加了@Pointcut注解的方法: 方法名()\n    */\n    @Before(\"pt()\")\n    public void methodbefore(){\n        System.out.println(\"方法被调用了\");\n    }\n\n}\n```\n#### 1.2.4 测试\n```java\n@Service\npublic class PhoneService {\n    public void deleteAll(){\n        System.out.println(\"PhoneService中deleteAll的核心代码\");\n    }\n}\n```\n```java\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        PhoneService phoneService = applicationContext.getBean(PhoneService.class);\n        phoneService.deleteAll();\n\n    }\n```\n```java\n测试结果：\n    方法被调用了\n    PhoneService中deleteAll的核心代码\n```\n### 1.3 AOP核心概念\n\n-  Joinpoint（连接点）：所谓连接点是指那些可以被增强到的点。在spring中,这些点指的是**方法**，因为spring只支持方法类型的连接点 \n-  **Pointcut（切入点）：所谓切入点是指被增强的连接点（方法）** \n-  **Advice（通知/ 增强）：所谓通知是指具体增强的代码** \n-  Target（目标对象）：被增强的对象就是目标对象 \n-  **Aspect（切面）：是切入点和通知（引介）的结合** \n-  Proxy （代理）：一个类被 AOP 增强后，就产生一个结果代理类 \n### 1.4 切点确定\n#### 1.4.1 切点表达式\n		可以使用切点表达式来表示要对哪些方法进行增强。\n写法：**execution([修饰符] 返回值类型 包名.类名.方法名(参数))**\n\n- 访问修饰符可以省略，大部分情况下省略\n- 返回值类型、包名、类名、方法名可以使用星号*  代表任意\n- 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类\n- 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表\n\n例如：\n```java\nexecution(* com.wxx.service.*.*(..))   表示com.wxx.service包下任意类，方法名任意，参数列表任意，返回值类型任意\n   \nexecution(* com.wxx.service..*.*(..))   表示com.wxx.service包及其子包下任意类，方法名任意，参数列表任意，返回值类型任意\n    \nexecution(* com.wxx.service.*.*())     表示com.wxx.service包下任意类，方法名任意，要求方法不能有参数，返回值类型任意\n    \nexecution(* com.wxx.service.*.delete*(..))     表示com.wxx.service包下任意类，要求方法不能有参数，返回值类型任意,方法名要求已delete开头\n```\n#### 1.4.2 切点函数@annotation  \n	我们也可以在要增强的方法上加上注解。然后使用@annotation来表示对加了什么注解的方法进行增强。\n写法：**@annotation(注解的全类名)**\n例如：\n定义注解如下\n```java\n@Target({ElementType.METHOD})//该注解可以加在方法上\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface InvokeLog {\n}\n```\n给需要增强的方法增加注解\n```java\n@Service\npublic class PhoneService {\n\n    @InvokeLog  \n    public void deleteAll(){\n        System.out.println(\"PhoneService中deleteAll的核心代码\");\n    }\n}\n```\n切面类中使用@annotation来确定要增强的方法\n```java\n@Component\n@Aspect\npublic class MyAspect {\n\n//    用Pointcut注解中的属性来指定对哪些方法进行增强\n    @Pointcut(\"@annotation(com.sangeng.aspect.InvokeLog)\")\n    public void pt(){}\n\n    /*\n        用@Before注解来指定该方法中是增强的代码，并且是在被增强方法执行前执行的\n        @Before的属性写上加了@Pointcut注解的方法: 方法名()\n    */\n    @Before(\"pt()\")\n    public void methodbefore(){\n        System.out.println(\"方法被调用了\");\n    }\n}\n```\n### 1.5 通知分类\n\n-  @Before：前置通知,在目标方法执行前执行 \n-  @AfterReturning： 返回后通知，在目标方法执行后执行，如果出现异常不会执行 \n-  @After：后置通知，在目标方法之后执行，无论是否出现异常都会执行 \n-  @AfterThrowing：异常通知，在目标方法抛出异常后执行 \n-  **@Around：环绕通知，围绕着目标方法执行** \n\n理解不同通知执行时机。（**下面的伪代码是用来理解单个通知的执行时机的，不能用来理解多个通知情况下的执行顺序。如果需要配置多个通知我们会选择使用Around通知，更加的清晰并且好用**）\n```java\n    public Object test() {\n        before();//@Before 前置通知\n        try {\n            Object ret = 目标方法();//目标方法调用\n            afterReturing();//@AfterReturning 返回后通知\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n            afterThrowing();//@AfterThrowing 异常通知通知\n        }finally {\n            after();//@After 后置通知\n        }\n        return ret;\n    }\n```\n环绕通知非常特殊，它可以对目标方法进行全方位的增强。\n例如：\n```java\n  	@Around(\"pt()\")\n    public void around(ProceedingJoinPoint pjp){\n        System.out.println(\"目标方法前\");\n        try {\n            pjp.proceed();//目标方法执行\n            System.out.println(\"目标方法后\");\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n            System.out.println(\"目标方法出现异常\");\n        }finally {\n            System.out.println(\"finally中进行增强\");\n        }\n    }\n```\n### 1.6 获取被增强方法相关信息\n	我们实际对方法进行增强时往往还需要获取到被增强代码的相关信息，比如方法名，参数，返回值，异常对象等。\n	我们可以在除了环绕通知外的所有通知方法中增加一个**JoinPoint类型**的参数。这个参数封装了被增强方法的相关信息。**我们可以通过这个参数获取到除了异常对象和返回值之外的所有信息。**\n例如：\n```java\n    @Before(\"pt()\")\n    public void methodbefore(JoinPoint jp){\n        Object[] args = jp.getArgs();//方法调用时传入的参数\n        Object target = jp.getTarget();//被代理对象\n        MethodSignature signature = (MethodSignature) jp.getSignature();//获取被被增强方法签名封装的对象\n        System.out.println(\"Before方法被调用了\");\n    }\n```\n案例：\n需求：要求让所有service包下类的所有方法被调用前都输出全类名，方法名，以及调用时传入的参数\n```java\n@Component\n@Aspect\npublic class PrintLogAspect {\n\n    //对哪些方法增强\n    @Pointcut(\"execution(* com.wxx.service..*.*(..))\")\n    public void pt(){}\n\n    //怎么增强\n    @Before(\"pt()\")\n    public void printLog(JoinPoint joinPoint){\n        //输出 被增强的方法所在的类名 方法名 调用时传入的参数   joinPoint.getSignature().getName()  joinPoint.getArgs()\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        //类名\n        String className = signature.getDeclaringTypeName();\n        //方法名\n        String methodName = signature.getName();\n        //调用时传入的参数\n        Object[] args = joinPoint.getArgs();\n\n        System.out.println(className+\"==\"+methodName+\"======\"+ Arrays.toString(args));\n    }\n}\n```\n	如果需要**获取被增强方法中的异常对象或者返回值**则需要在方法参数上增加一个对应类型的参数，并且使用注解的属性进行配置。这样Spring会把你想获取的数据赋值给对应的方法参数。\n例如：\n```java\n    @AfterReturning(value = \"pt()\",returning = \"ret\")//使用returning属性指定了把目标方法返回值赋值给下面方法的参数ret\n    public void AfterReturning(JoinPoint jp,Object ret){\n        System.out.println(\"AfterReturning方法被调用了\");\n    }\n```\n```java\n    @AfterThrowing(value = \"pt()\",throwing = \"t\")//使用throwing属性指定了把出现的异常对象赋值给下面方法的参数t\n    public void AfterThrowing(JoinPoint jp,Throwable t){\n        System.out.println(\"AfterReturning方法被调用了\");\n    }\n```\n	相信你肯定觉得上面的获取方式特别的麻烦难以理解。就可以使用下面这种万能的方法。\n	直接在环绕通知方法中增加一个**ProceedingJoinPoint类型**的参数。这个参数封装了被增强方法的相关信息。\n该参数的proceed()方法被调用相当于被增强方法被执行，调用后的返回值就相当于被增强方法的返回值。\n例如：\n```java\n    @Around(value = \"pt()\")\n    public Object around(ProceedingJoinPoint pjp) {\n        Object[] args = pjp.getArgs();//方法调用时传入的参数\n        Object target = pjp.getTarget();//被代理对象\n        MethodSignature signature = (MethodSignature) pjp.getSignature();//获取被被增强方法签名封装的对象\n        Object ret = null;\n        try {\n            ret = pjp.proceed();//ret就是目标方法执行后的返回值\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();//throwable就是出现异常时的异常对象\n        }\n        return ret;\n    }\n```\n### 1.7 AOP应用案例\n#### 1.7.1 需求\n现有AI核心功能代码如下：\n```java\npublic class AIController {\n    //AI自动回答\n    public String getAnswer(String question){\n        //AI核心代码 价值10个亿\n        String str = question.replace(\"吗\", \"\");\n        str = str.replace(\"？\",\"!\");\n        return str;\n    }\n\n    //AI算命\n    public String fortuneTelling(String name){\n        //AI算命核心代码\n        String[] strs = {\"女犯伤官把夫克，旱地莲花栽不活，不是吃上两家饭，也要刷上三家锅。\",\"一朵鲜花头上戴，一年四季也不开，一心想要花开时，采花之人没到来。\",\"此命生来脾气暴，上来一阵双脚跳，对你脾气啥都好，经常与人吵和闹。\"};\n        int index = name.hashCode() % 3;\n\n        return strs[index];\n    }\n}\n```\n		现在为了保证数据的安全性，要求调用方法时fortuneTelling传入的姓名是经过加密的。我们需要对传入的参数进行解密后才能使用。并且要对该方法的返回值进行加密后返回。\n		**PS:后期也可能让其他方法进行相应的加密处理。**\n字符串加密解密直接使用下面的工具类即可：\n```java\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.SecureRandom;\n\npublic class CryptUtil {\n    private static final String AES = \"AES\";\n\n    private static int keysizeAES = 128;\n\n    private static String charset = \"utf-8\";\n\n    public static String parseByte2HexStr(final byte buf[]) {\n        final StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < buf.length; i++) {\n            String hex = Integer.toHexString(buf[i] & 0xFF);\n            if (hex.length() == 1) {\n                hex = \'0\' + hex;\n            }\n            sb.append(hex.toUpperCase());\n        }\n        return sb.toString();\n    }\n\n    public static byte[] parseHexStr2Byte(final String hexStr) {\n        if (hexStr.length() < 1)\n            return null;\n        final byte[] result = new byte[hexStr.length() / 2];\n        for (int i = 0;i< hexStr.length()/2; i++) {\n            int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);\n            int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16);\n            result[i] = (byte) (high * 16 + low);\n        }\n        return result;\n    }\n\n    private static String keyGeneratorES(final String res, final String algorithm, final String key, final Integer keysize, final Boolean bEncode) {\n        try {\n            final KeyGenerator g = KeyGenerator.getInstance(algorithm);\n            if (keysize == 0) {\n                byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset);\n                g.init(new SecureRandom(keyBytes));\n            } else if (key == null) {\n                g.init(keysize);\n            } else {\n                byte[] keyBytes = charset == null ? key.getBytes() : key.getBytes(charset);\n                SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n                random.setSeed(keyBytes);\n                g.init(keysize, random);\n            }\n            final SecretKey sk = g.generateKey();\n            final SecretKeySpec sks = new SecretKeySpec(sk.getEncoded(), algorithm);\n            final Cipher cipher = Cipher.getInstance(algorithm);\n            if (bEncode) {\n                cipher.init(Cipher.ENCRYPT_MODE, sks);\n                final byte[] resBytes = charset == null? res.getBytes() : res.getBytes(charset);\n                return parseByte2HexStr(cipher.doFinal(resBytes));\n            } else {\n                cipher.init(Cipher.DECRYPT_MODE, sks);\n                return new String(cipher.doFinal(parseHexStr2Byte(res)));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String AESencode(final String res) {\n        return keyGeneratorES(res, AES, \"aA11*-%\", keysizeAES, true);\n    }\n\n    public static String AESdecode(final String res) {\n        return keyGeneratorES(res, AES, \"aA11*-%\", keysizeAES, false);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\n                \"加密后:\" + AESencode(\"将要加密的明文\")\n        );\n        System.out.println(\n                \"解密后:\" + AESdecode(\"730CAE52D85B372FB161B39D0A908B8CC6EF6DA2F7D4E595D35402134C3E18AB\")\n        );\n    }\n}\n```\n#### 1.7.2  实现\n##### ①导入依赖\n```xml\n        <!--SpringIOC相关依赖-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n        <!--AOP相关依赖-->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n```\n##### ②开启AOP注解支持\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n\n    <!--配置组件扫描-->\n    <context:component-scan base-package=\"com.wxx\"></context:component-scan>\n    <!--启动AOP注解支持-->\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n</beans>\n```\n③自定义注解\n```java\npackage com.sangeng.aspect;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Crypt {\n\n}\n```\n④在目标方法上增加注解\n**注意：目标对象一定要记得注入Spring容器中**\n```java\n@Controller\npublic class AIController {\n	//....\n\n    //AI算命\n    @Crypt\n    public String fortuneTelling(String name){\n        System.out.println(name);\n              //AI算命核心代码\n        String[] strs = {\"女犯伤官把夫克，旱地莲花栽不活，不是吃上两家饭，也要刷上三家锅。\",\"一朵鲜花头上戴，一年四季也不开，一心想要花开时，采花之人没到来。\",\"此命生来脾气暴，上来一阵双脚跳，对你脾气啥都好，经常与人吵和闹。\"};\n        int index = name.hashCode() % 3;\n\n        return strs[index];\n    }\n}\n```\n##### ⑤定义切面类\n```java\npackage com.sangeng.aspect;\n\nimport com.sangeng.util.CryptUtil;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Aspect\npublic class CryptAspect {\n\n    //确定切点\n    @Pointcut(\"@annotation(com.wxx.aspect.Crypt)\")\n    public void pt(){\n\n    }\n\n    //定义通知\n    @Around(\"pt()\")\n    public Object crypt(ProceedingJoinPoint pjp) {\n        //获取去目标方法调用时的参数\n        Object[] args = pjp.getArgs();\n        //对参数进行解密  解密后传入目标方法执行\n        String arg = (String) args[0];\n        String s = CryptUtil.AESdecode(arg);//解密\n        args[0] = s;\n        Object proceed = null;\n        String ret = null;\n        try {\n            proceed = pjp.proceed(args);//目标方法调用\n            //目标方法执行后需要获取到返回值\n            ret = (String) proceed;\n            //对返回值加密后进行真正的返回\n            ret = CryptUtil.AESencode(ret);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        return ret;\n    }\n\n}\n```\n### 1.8 xml配置AOP\n#### ①定义切面类\n\n```java\npublic class MyAspect {\n\n\n    public void before(JoinPoint joinPoint){\n        System.out.println(\"before\");\n    }\n\n//    @AfterReturning(value = \"pt()\",returning = \"ret\")\n    public void afterReturning(JoinPoint joinPoint,Object ret){\n        System.out.println(\"afterReturning:\"+ret);\n    }\n//    @After(\"pt()\")\n    public void after(JoinPoint joinPoint){\n        System.out.println(\"after\");\n    }\n\n//    @AfterThrowing(value = \"pt()\",throwing = \"e\")\n    public void afterThrowing(JoinPoint joinPoint,Throwable e){\n        String message = e.getMessage();\n        System.out.println(\"afterThrowing:\"+message);\n    }\n\n    public Object around(ProceedingJoinPoint pjp){\n        //获取参数\n        Object[] args = pjp.getArgs();\n        MethodSignature signature = (MethodSignature) pjp.getSignature();\n        Object target = pjp.getTarget();\n        Object ret = null;\n        try {\n            ret = pjp.proceed();//目标方法的执行\n            //ret就是被增强方法的返回值\n            System.out.println(ret);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n            System.out.println(throwable.getMessage());\n        }\n//        System.out.println(pjp);\n        return ret;\n    }\n}\n```\n#### ②目标类和切面类注入容器\n在切面类和目标类上加是对应的注解。注入如果是使用注解的方式注入容器要记得开启组件扫描。\n当然你也可以在xml中使用bean标签的方式注入容器。\n```java\n@Component//把切面类注入容器\npublic class MyAspect {\n	//..。省略无关代码\n}\n```\n```java\n@Service//把目标类注入容器\npublic class UserService {\n	//..。省略无关代码\n}\n```\n#### ③配置AOP\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--开启组件扫描-->\n    <context:component-scan base-package=\"com.wxx\"></context:component-scan>\n\n    <!--配置AOP-->\n    <aop:config>\n        <!--定义切点-->\n        <aop:pointcut id=\"pt1\" expression=\"execution(* com.sangeng.service..*.*(..))\"></aop:pointcut>\n        <aop:pointcut id=\"pt2\" expression=\"@annotation(com.sangeng.aspect.InvokeLog)\"></aop:pointcut>\n        <!--配置切面-->\n        <aop:aspect ref=\"myAspect\">\n            <aop:before method=\"before\" pointcut-ref=\"pt1\"></aop:before>\n            <aop:after method=\"after\" pointcut-ref=\"pt1\"></aop:after>\n            <aop:after-returning method=\"afterReturning\" pointcut-ref=\"pt1\" returning=\"ret\"></aop:after-returning>\n            <aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"pt2\" throwing=\"e\"></aop:after-throwing>\n        </aop:aspect>\n    </aop:config>\n</beans>\n```\n### 1.9 多切面顺序问题\n	在实际项目中我们可能会存在配置了多个切面的情况。这种情况下我们很可能需要控制切面的顺序。\n	我们在默认情况下Spring有它自己的排序规则。（按照类名排序）\n	默认排序规则往往不符合我们的要求，我们需要进行特殊控制。\n	如果是注解方式配置的AOP可以在切面类上加**@Order注解**来控制顺序。**@Order中的属性越小优先级越高。**\n	如果是XML方式配置的AOP,可以通过调整**配置顺序**来控制。\n例如：\n下面这种配置方式就会先使用CryptAspect里面的增强，在使用APrintLogAspect里的增强\n```java\n@Component\n@Aspect\n@Order(2)\npublic class APrintLogAspect {\n    //省略无关代码\n}\n@Component\n@Aspect\n@Order(1)\npublic class CryptAspect {\n    //省略无关代码\n}\n```\n### 1.10 AOP原理-动态代理\n	实际上Spring的AOP其实底层就是使用动态代理来完成的。并且使用了两种动态代理分别是JDK的动态代理和Cglib动态代理。\n	所以我们接下去来学习下这两种动态代理，理解下它们的不同点。\n#### 1.10.1 JDK动态代理\n	JDK的动态代理使用的java.lang.reflect.Proxy这个类来进行实现的。要求被代理（被增强）的类需要实现了接口。并且JDK动态代理也只能对接口中的方法进行增强。\n```java\npublic static void main(String[] args) {\n        AIControllerImpl aiController = new AIControllerImpl();\n        //使用动态代理增强getAnswer方法\n        //1.JDK动态代理\n        //获取类加载器\n        ClassLoader cl = Demo.class.getClassLoader();\n        //被代理类所实现接口的字节码对象数组\n        Class<?>[] interfaces = AIControllerImpl.class.getInterfaces();\n        AIController proxy = (AIController) Proxy.newProxyInstance(cl, interfaces, new InvocationHandler() {\n            //使用代理对象的方法时 会调用到invoke\n                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                //proxy   是代理对象\n                //method 是当前被调用的方法封装的Method对象\n                //args   是调用方法时传入的参数\n                //调用被代理对象的对应方法\n                //判断 当前调用的是否是getAnswer方法\n                if(method.getName().equals(\"getAnswer\")){\n                    System.out.println(\"增强\");\n                }\n                Object ret = method.invoke(aiController, args);\n                return ret;\n            }\n        });\n        String answer = proxy.getAnswer(\"三连了吗？\");\n		System.out.println(answer);\n    }\n```\n#### 1.10.2 Cglib动态代理\n	使用的是org.springframework.cglib.proxy.Enhancer类进行实现的。\n```java\npublic class CglibDemo {\n    public static void main(String[] args) {\n        Enhancer enhancer = new Enhancer();\n        //设置父类的字节码对象\n        enhancer.setSuperclass(AIControllerImpl.class);\n        enhancer.setCallback(new MethodInterceptor() {\n            //使用代理对象执行方法是都会调用到intercept方法\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                //判断当前调用的方法是不是getAnswer方法 如果是进行增强\n                if (\"getAnswer\".equals(method.getName())){\n                    System.out.println(\"被增强了\");\n                }\n                //调用父类中对应的方法\n                Object ret = methodProxy.invokeSuper(o, objects);\n                return ret;\n            }\n        });\n        //生成代理对象\n        AIControllerImpl proxy = (AIControllerImpl) enhancer.create();\n//        System.out.println(proxy.getAnswer(\"你好吗？\"));\n        System.out.println(proxy.fortuneTelling(\"你好吗？\"));\n    }\n}\n```\n#### 1.10.3 总结\n	JDK动态代理要求被代理（被增强）的类必须要实现接口，生成的代理对象相当于是被代理对象的兄弟。\n	Cglib的动态代理不要求被代理（被增强）的类要实现接口，生成的代理对象相当于被代理对象的子类对象。\n	**Spring的AOP默认情况下优先使用的是JDK的动态代理，如果使用不了JDK的动态代理才会使用Cglib的动态代理。**\n### 1.11 切换默认动态代理方式\n	有的时候我们需要修改AOP的代理方式。\n	我们可以使用以下方式修改：\n如果我们是采用注解方式配置AOP的话：\n设置aop:aspectj-autoproxy标签的proxy-target-class属性为true，代理方式就会修改成Cglib\n```xml\n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n```\n如果我们是采用xml方式配置AOP的话：\n设置aop:config标签的proxy-target-class属性为true,代理方式就会修改成Cglib\n```xml\n<aop:config proxy-target-class=\"true\">\n</aop:config>\n```\n','Spring入门博客共有4篇，分别是Spring入门01-04',16,'rzpy18v9b.hn-bkt.clouddn.com/2023/11/23/9dc732ef31f14a23b155da22fe0602a5.png','1','0',0,'0',1,'2023-11-23 01:29:22',NULL,'2023-11-23 01:35:48',0),(12,'Spring入门04','## 1.Spring整合Junit\n### ①导入依赖\n```xml\n<!-- junit -->\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n</dependency>\n<!-- spring整合junit的依赖 -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-test</artifactId>\n    <version>5.1.9.RELEASE</version>\n</dependency>\n```\n### ② 编写测试类\n在测试类上加上\n**@RunWith(SpringJUnit4ClassRunner.class)**注解，指定让测试运行于Spring环境\n**@ContextConfiguration注解**，指定Spring容器创建需要的配置文件或者配置类\n```java\n@RunWith(SpringJUnit4ClassRunner.class)//让测试运行与Spring测试环境\n@ContextConfiguration(locations = \"classpath:配置文件1.xml\")//设置Spring配置文件或者配置类\n//@ContextConfiguration(classes = SpringConfig.class)\npublic class SpringTest {}\n```\n### ③注入对象进行测试\n在测试类中注入要测试的对象，定义测试方法，在其中使用要测试的对象。\n```java\n@RunWith(SpringJUnit4ClassRunner.class)//让测试运行与Spring测试环境\n@ContextConfiguration(locations = \"classpath:配置文件1.xml\")//设置Spring配置文件或者配置类\n//@ContextConfiguration(classes = SpringConfig.class)\npublic class SpringTest {\n    \n    // 想测哪个对象，就注入哪个对象\n    @Autowired\n    private UserService userService;\n    \n    //定义测试方法\n    @Test\n    public void testUserService() {\n        userService.findById(10);\n    }\n    \n}\n```\n## 2.Spring整合Mybatis\n	我们如果想把Mybatis整合到Spring中需要使用一个整合包**mybatis-spring**\n	官方文档：[http://mybatis.org/spring/zh/index.html](http://mybatis.org/spring/zh/index.html)\n### ①导入依赖\n```xml\n	<!-- spring-jdbc -->\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.1.9.RELEASE</version>\n    </dependency>\n\n    <!-- mybatis整合到Spring的整合包 -->\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.4</version>\n    </dependency>\n\n    <!--mybatis依赖-->\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.4</version>\n    </dependency>\n    <!--mysql驱动-->\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.47</version>\n    </dependency>\n\n    <!-- druid数据源 -->\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n        <version>1.1.16</version>\n    </dependency>\n```\n### ②往容器中注入整合相关对象\nresource目录下applicationContext.xml文件写入：\n```xml\n    <!--读取properties文件-->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"></context:property-placeholder>\n    <!--创建连接池注入容器-->\n    <bean class=\"com.alibaba.druid.pool.DruidDataSource\" id=\"dataSource\">\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n    </bean>   \n<!--spring整合mybatis后控制的创建获取SqlSessionFactory的对象-->\n    <bean class=\"org.mybatis.spring.SqlSessionFactoryBean\" id=\"sessionFactory\">\n        <!--配置连接池-->\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n        <!--配置mybatis配置文件的路径-->\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"></property>\n    </bean>\n\n    <!--mapper扫描配置，扫描到的mapper对象会被注入Spring容器中-->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\" id=\"mapperScannerConfigurer\">\n        <property name=\"basePackage\" value=\"com.wxx.dao\"></property>\n    </bean>\n```\nresource目录下mybatis配置文件**mybatis-config.xml**如下:\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <typeAliases>\n        <package name=\"com.wxx.domain\"></package>\n    </typeAliases>\n</configuration>\n```\n### ③从容器中获取Mapper对象进行使用\n```java\n    @Autowired\n    private UserDao userDao;\n```\n## 3.Spring声明式事务\n### 3.1 事务回顾\n#### **3.1.1 事务的概念**\n		保证一组数据库的操作，要么同时成功，要么同时失败\n#### 3.1.2 四大特性\n\n-  隔离性\n多个事务之间要相互隔离，不能互相干扰 \n-  原子性\n指事务是一个不可分割的整体，类似一个不可分割的原子 \n-  一致性\n保障事务前后这组数据的状态是一致的。要么都是成功的，要么都是失败的。 \n-  持久性\n指事务一旦被提交，这组操作修改的数据就真的的发生变化了。即使接下来数据库故障也不应该对其有影响。 \n### 3.2 实现声明式事务\n	如果我们自己去对事务进行控制的话我们就需要值原来核心代码的基础上加上事务控制相关的代码。而在我们的实际开发中这种事务控制的操作也是非常常见的。所以Spring提供了声明式事务的方式让我们去控制事务。\n	只要简单的加个注解(或者是xml配置)就可以实现事务控制，不需要事务控制的时候只需要去掉相应的注解即可。\n#### 3.2.0 案例环境准备\n①数据初始化\n```\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`spring_db` /*!40100 DEFAULT CHARACTER SET utf8 */;\nUSE `spring_db`;\nDROP TABLE IF EXISTS `account`;\nCREATE TABLE `account` (\n  `id` INT(11) NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) DEFAULT NULL,\n  `money` DOUBLE DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\nINSERT  INTO `account`(`id`,`name`,`money`) VALUES (1,\'三更\',100),(2,\'草堂\',100);\n```\n②Spring整合Mybatis\n③创建Service和Dao\n```java\npublic interface AccountService {\n    /**\n     * 转账\n     * @param outId 转出账户的id\n     * @param inId 转出账户的id\n     * @param money 转账金额\n     */\n    public void transfer(Integer outId,Integer inId,Double money);\n}\n```\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n\n    @Autowired\n    private AccoutDao accoutDao;\n\n    public void transfer(Integer outId, Integer inId, Double money) {\n        //增加\n        accoutDao.updateMoney(inId,money);\n        //减少\n        accoutDao.updateMoney(outId,-money);\n    }\n}\n```\n```java\npublic interface AccoutDao {\n\n    void updateMoney(@Param(\"id\") Integer id,@Param(\"updateMoney\") Double updateMoney);\n}\n```\nAccoutDao.xml如下：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n<mapper namespace=\"com.wxx.dao.AccoutDao\">\n\n\n    <update id=\"updateMoney\">\n        update  account set money = money + #{updateMoney} where id = #{id}\n    </update>\n</mapper>\n```\n#### 3.2.1 注解实现\n##### ①配置事务管理器和事务注解驱动\n在spring的配置文件中添加如下配置：\n```xml\n    <!--把事务管理器注入Spring容器，需要配置一个连接池-->\n    <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n    <!--开启事务注解驱动，配置使用的事务管理器-->\n    <tx:annotation-driven transaction-manager=\"txManager\"/>\n```\n##### ②添加注解\n在需要进行事务控制的方法或者类上添加@Transactional注解就可以实现事务控制。\n```java\n    @Transactional\n    public void transfer(Integer outId, Integer inId, Double money) {\n        //增加\n        accoutDao.updateMoney(inId,money);\n//        System.out.println(1/0);\n        //减少\n        accoutDao.updateMoney(outId,-money);\n    }\n```\n**注意：如果加在类上，这个类的所有方法都会受事务控制，如果加在方法上，就是那一个方法受事务控制。**\n注意，因为声明式事务底层是通过AOP实现的，所以最好把AOP相关依赖都加上。\n```xml\n       <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.6</version>\n        </dependency>\n```\n#### 3.2.2 xml方式实现\n##### ①配置事务管理器\n```xml\n    <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n```\n##### ②配置事务切面\n```xml\n 	<!--定义事务管理的通知类-->\n    <tx:advice transaction-manager=\"txManager\" id=\"txAdvice\">\n        <tx:attributes>\n            <tx:method name=\"trans*\"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <aop:config>\n        <aop:pointcut id=\"pt\" expression=\"execution(* com.wxx.service..*.*(..))\"></aop:pointcut>\n        <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pt\"></aop:advisor>\n    </aop:config>\n```\n注意，因为声明式事务底层是通过AOP实现的，所以最好把AOP相关依赖都加上。\n```xml\n       <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.6</version>\n        </dependency>\n```\n### 3.3 属性配置\n#### 3.3.1 事务传播行为propagation\n	当事务方法嵌套调用时，需要控制是否开启新事务，可以使用事务传播行为来控制。\n测试案例:\n日志事务发生故障，事务会回滚，\n```java\n@Service\npublic class TestServiceImpl {\n    @Autowired\n    AccountService accountService;\n\n    @Transactional\n    public void test(){\n        accountService.transfer(1,2,10D);\n        accountService.log();\n    }\n}\n```\n```java\npublic class AccountServiceImpl implements AccountService {\n	//...省略其他不相关代码\n    @Transactional\n    public void log() {\n        System.out.println(\"打印日志\");\n        int i = 1/0;\n    }\n\n}\n```\n| 属性值 | 行为 |\n| --- | --- |\n| REQUIRED（必须要有） | 外层方法有事务，内层方法就加入。外层没有，内层就新建 |\n| REQUIRES_NEW（必须要有新事务） | 外层方法有事务，内层方法新建。外层没有，内层也新建 |\n| SUPPORTS（支持有） | 外层方法有事务，内层方法就加入。外层没有，内层就也没有 |\n| NOT_SUPPORTED（支持没有） | 外层方法有事务，内层方法没有。外层没有，内层也没有 |\n| MANDATORY（强制要求外层有） | 外层方法有事务，内层方法加入。外层没有。内层就报错 |\n| NEVER(绝不允许有) | 外层方法有事务，内层方法就报错。外层没有。内层就也没有 |\n\n例如：\n```java\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void transfer(Integer outId, Integer inId, Double money) {\n        //增加\n        accoutDao.updateMoney(inId,money);\n        //减少\n        accoutDao.updateMoney(outId,-money);\n    }\n```\n#### 3.3.2 隔离级别isolation\nIsolation.DEFAULT 使用数据库默认隔离级别\nIsolation.READ_UNCOMMITTED\nIsolation.READ_COMMITTED\nIsolation.REPEATABLE_READ\nIsolation.SERIALIZABLE\n```java\n   @Transactional(propagation = Propagation.REQUIRES_NEW,isolation = Isolation.READ_COMMITTED)\n    public void transfer(Integer outId, Integer inId, Double money) {\n        //增加\n        accoutDao.updateMoney(inId,money);\n        //减少\n        accoutDao.updateMoney(outId,-money);\n    }\n```\n#### 3.3.3 只读readOnly\n	如果事务中的操作都是读操作，没涉及到对数据的写操作可以设置readOnly为true。这样可以提高效率。\n```java\n    @Transactional(readOnly = true)\n    public void log() {\n        System.out.println(\"打印日志\");\n        int i = 1/0;\n    }\n```\n','Spring入门博客共有4篇，分别是Spring入门01-04',16,'rzpy18v9b.hn-bkt.clouddn.com/2023/11/23/e5d5981395f24769ad3ae1a89a6a1689.png','1','0',0,'0',1,'2023-11-23 01:31:26',1,'2023-11-23 01:31:26',0);

/*Table structure for table `ez_article_tag` */

DROP TABLE IF EXISTS `ez_article_tag`;

CREATE TABLE `ez_article_tag` (
  `article_id` bigint NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `tag_id` bigint NOT NULL DEFAULT '0' COMMENT '标签id',
  PRIMARY KEY (`article_id`,`tag_id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文章标签关联表';

/*Data for the table `ez_article_tag` */

insert  into `ez_article_tag`(`article_id`,`tag_id`) values (9,4),(10,4),(11,4),(12,4);

/*Table structure for table `ez_category` */

DROP TABLE IF EXISTS `ez_category`;

CREATE TABLE `ez_category` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(128) DEFAULT NULL COMMENT '分类名',
  `pid` bigint DEFAULT '-1' COMMENT '父分类id，如果没有父分类为-1',
  `description` varchar(512) DEFAULT NULL COMMENT '描述',
  `status` char(1) DEFAULT '0' COMMENT '状态0:正常,1禁用',
  `create_by` bigint DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='分类表';

/*Data for the table `ez_category` */

insert  into `ez_category`(`id`,`name`,`pid`,`description`,`status`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (1,'Java',-1,'后端','0',NULL,NULL,NULL,'2023-11-23 01:27:14',0),(2,'PHP',-1,'后端','0',NULL,NULL,NULL,'2023-11-23 01:20:58',0),(15,'JS',-1,'前端','0',1,'2023-09-26 01:44:46',1,'2023-09-26 01:44:46',1),(16,'Spring',-1,'java后端框架','0',1,'2023-11-23 01:20:46',1,'2023-11-23 01:22:01',0);

/*Table structure for table `ez_comment` */

DROP TABLE IF EXISTS `ez_comment`;

CREATE TABLE `ez_comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `type` char(1) DEFAULT '0' COMMENT '评论类型（0代表文章评论，1代表友链评论）',
  `article_id` bigint DEFAULT NULL COMMENT '文章id',
  `root_id` bigint DEFAULT '-1' COMMENT '根评论id',
  `content` varchar(512) DEFAULT NULL COMMENT '评论内容',
  `to_comment_user_id` bigint DEFAULT '-1' COMMENT '所回复的目标评论的userid',
  `to_comment_id` bigint DEFAULT '-1' COMMENT '回复目标评论id',
  `create_by` bigint DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='评论表';

/*Data for the table `ez_comment` */

insert  into `ez_comment`(`id`,`type`,`article_id`,`root_id`,`content`,`to_comment_user_id`,`to_comment_id`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (1,'0',1,-1,'asS',-1,-1,1,'2022-01-29 07:59:22',1,'2022-01-29 07:59:22',0),(38,'1',1,1,'你好',1,1,1,'2023-08-15 11:00:05',1,'2023-08-15 11:00:05',0),(39,'1',1,-1,'感谢，这个贴对我很有帮助',-1,-1,1,'2023-08-15 11:00:18',1,'2023-08-15 11:00:18',0),(40,'1',1,-1,'你好',-1,-1,-1,'2023-11-23 09:58:29',-1,'2023-11-23 09:58:29',0),(41,'1',1,-1,'你好',-1,-1,-1,'2023-11-23 09:58:45',-1,'2023-11-23 09:58:45',0);

/*Table structure for table `ez_link` */

DROP TABLE IF EXISTS `ez_link`;

CREATE TABLE `ez_link` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(256) DEFAULT NULL,
  `logo` varchar(256) DEFAULT NULL,
  `description` varchar(512) DEFAULT NULL,
  `address` varchar(128) DEFAULT NULL COMMENT '网站地址',
  `status` char(1) DEFAULT '2' COMMENT '审核状态 (0代表审核通过，1代表审核未通过，2代表未审核)',
  `create_by` bigint DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='友链';

/*Data for the table `ez_link` */

insert  into `ez_link`(`id`,`name`,`logo`,`description`,`address`,`status`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (4,'MybatisPlus的学习与使用','https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png','对MybatisPlus常用函数进行学习与使用','www.baidu.com','0',1,'2023-09-26 02:08:44',1,'2023-09-26 02:08:44',0);

/*Table structure for table `ez_tag` */

DROP TABLE IF EXISTS `ez_tag`;

CREATE TABLE `ez_tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(128) DEFAULT NULL COMMENT '标签名',
  `create_by` bigint DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_by` bigint DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `del_flag` int DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='标签';

/*Data for the table `ez_tag` */

insert  into `ez_tag`(`id`,`name`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`,`remark`) values (1,'Mybatis',1,NULL,NULL,'2023-11-23 01:27:01',0,''),(4,'Java',1,'2022-01-13 15:22:43',NULL,'2023-11-23 01:26:58',0,'');

/*Table structure for table `sys_menu` */

DROP TABLE IF EXISTS `sys_menu`;

CREATE TABLE `sys_menu` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '菜单ID',
  `menu_name` varchar(50) NOT NULL COMMENT '菜单名称',
  `parent_id` bigint DEFAULT '0' COMMENT '父菜单ID',
  `order_num` int DEFAULT '0' COMMENT '显示顺序',
  `path` varchar(200) DEFAULT '' COMMENT '路由地址',
  `component` varchar(255) DEFAULT NULL COMMENT '组件路径',
  `is_frame` int DEFAULT '1' COMMENT '是否为外链（0是 1否）',
  `menu_type` char(1) DEFAULT '' COMMENT '菜单类型（M目录 C菜单 F按钮）',
  `visible` char(1) DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `status` char(1) DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',
  `perms` varchar(100) DEFAULT NULL COMMENT '权限标识',
  `icon` varchar(100) DEFAULT '#' COMMENT '菜单图标',
  `create_by` bigint DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) DEFAULT '' COMMENT '备注',
  `del_flag` char(1) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2034 DEFAULT CHARSET=utf8mb3 COMMENT='菜单权限表';

/*Data for the table `sys_menu` */

insert  into `sys_menu`(`id`,`menu_name`,`parent_id`,`order_num`,`path`,`component`,`is_frame`,`menu_type`,`visible`,`status`,`perms`,`icon`,`create_by`,`create_time`,`update_by`,`update_time`,`remark`,`del_flag`) values (1,'系统管理',0,1,'system',NULL,1,'M','0','0','','system',0,'2021-11-12 10:46:19',0,NULL,'系统管理目录','0'),(100,'用户管理',1,1,'user','system/user/index',1,'C','0','0','system:user:list','user',0,'2021-11-12 10:46:19',1,'2022-07-31 15:47:58','用户管理菜单','0'),(101,'角色管理',1,2,'role','system/role/index',1,'C','0','0','system:role:list','peoples',0,'2021-11-12 10:46:19',0,NULL,'角色管理菜单','0'),(102,'菜单管理',1,3,'menu','system/menu/index',1,'C','0','0','system:menu:list','tree-table',0,'2021-11-12 10:46:19',0,NULL,'菜单管理菜单','0'),(1001,'用户查询',100,1,'','',1,'F','0','0','system:user:query','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1002,'用户新增',100,2,'','',1,'F','0','0','system:user:add','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1003,'用户修改',100,3,'','',1,'F','0','0','system:user:edit','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1004,'用户删除',100,4,'','',1,'F','0','0','system:user:remove','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1005,'用户导出',100,5,'','',1,'F','0','0','system:user:export','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1006,'用户导入',100,6,'','',1,'F','0','0','system:user:import','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1007,'重置密码',100,7,'','',1,'F','0','0','system:user:resetPwd','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1008,'角色查询',101,1,'','',1,'F','0','0','system:role:query','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1009,'角色新增',101,2,'','',1,'F','0','0','system:role:add','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1010,'角色修改',101,3,'','',1,'F','0','0','system:role:edit','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1011,'角色删除',101,4,'','',1,'F','0','0','system:role:remove','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1012,'角色导出',101,5,'','',1,'F','0','0','system:role:export','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1013,'菜单查询',102,1,'','',1,'F','0','0','system:menu:query','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1014,'菜单新增',102,2,'','',1,'F','0','0','system:menu:add','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1015,'菜单修改',102,3,'','',1,'F','0','0','system:menu:edit','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(1016,'菜单删除',102,4,'','',1,'F','0','0','system:menu:remove','#',0,'2021-11-12 10:46:19',0,NULL,'','0'),(2017,'内容管理',0,4,'content',NULL,1,'M','0','0',NULL,'table',NULL,'2022-01-08 02:44:38',1,'2022-07-31 12:34:23','','0'),(2018,'分类管理',2017,1,'category','content/category/index',1,'C','0','0','content:category:list','example',NULL,'2022-01-08 02:51:45',NULL,'2022-01-08 02:51:45','','0'),(2019,'文章管理',2017,0,'article','content/article/index',1,'C','0','0','content:article:list','build',NULL,'2022-01-08 02:53:10',NULL,'2022-01-08 02:53:10','','0'),(2021,'标签管理',2017,6,'tag','content/tag/index',1,'C','0','0','content:tag:index','button',NULL,'2022-01-08 02:55:37',NULL,'2022-01-08 02:55:50','','0'),(2022,'友链管理',2017,4,'link','content/link/index',1,'C','0','0','content:link:list','404',NULL,'2022-01-08 02:56:50',NULL,'2022-01-08 02:56:50','','0'),(2023,'写博文',0,0,'write','content/article/write/index',1,'C','0','0','content:article:writer','build',NULL,'2022-01-08 03:39:58',1,'2022-07-31 22:07:05','','0'),(2024,'友链新增',2022,0,'',NULL,1,'F','0','0','content:link:add','#',NULL,'2022-01-16 07:59:17',NULL,'2022-01-16 07:59:17','','0'),(2025,'友链修改',2022,1,'',NULL,1,'F','0','0','content:link:edit','#',NULL,'2022-01-16 07:59:44',NULL,'2022-01-16 07:59:44','','0'),(2026,'友链删除',2022,1,'',NULL,1,'F','0','0','content:link:remove','#',NULL,'2022-01-16 08:00:05',NULL,'2022-01-16 08:00:05','','0'),(2027,'友链查询',2022,2,'',NULL,1,'F','0','0','content:link:query','#',NULL,'2022-01-16 08:04:09',NULL,'2022-01-16 08:04:09','','0'),(2028,'导出分类',2018,1,'',NULL,1,'F','0','0','content:category:export','#',NULL,'2022-01-21 07:06:59',NULL,'2022-01-21 07:06:59','','0');

/*Table structure for table `sys_role` */

DROP TABLE IF EXISTS `sys_role`;

CREATE TABLE `sys_role` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(30) NOT NULL COMMENT '角色名称',
  `role_key` varchar(100) NOT NULL COMMENT '角色权限字符串',
  `role_sort` int NOT NULL COMMENT '显示顺序',
  `status` char(1) NOT NULL COMMENT '角色状态（0正常 1停用）',
  `del_flag` char(1) DEFAULT '0' COMMENT '删除标志（0代表存在 1代表删除）',
  `create_by` bigint DEFAULT NULL COMMENT '创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint DEFAULT NULL COMMENT '更新者',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb3 COMMENT='角色信息表';

/*Data for the table `sys_role` */

insert  into `sys_role`(`id`,`role_name`,`role_key`,`role_sort`,`status`,`del_flag`,`create_by`,`create_time`,`update_by`,`update_time`,`remark`) values (1,'超级管理员','admin',1,'0','0',0,'2021-11-12 10:46:19',0,NULL,'超级管理员'),(12,'友链审核员','link',1,'0','0',NULL,'2022-01-16 06:49:30',NULL,'2022-01-16 08:05:09',NULL),(13,'普通角色','common',2,'0','0',1,'2023-09-27 08:11:38',1,'2023-09-27 08:11:38',NULL),(14,'测试2','test',4,'0','0',1,'2023-09-27 08:39:23',1,'2023-09-27 09:12:45',NULL);

/*Table structure for table `sys_role_menu` */

DROP TABLE IF EXISTS `sys_role_menu`;

CREATE TABLE `sys_role_menu` (
  `role_id` bigint NOT NULL COMMENT '角色ID',
  `menu_id` bigint NOT NULL COMMENT '菜单ID',
  PRIMARY KEY (`role_id`,`menu_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT='角色和菜单关联表';

/*Data for the table `sys_role_menu` */

insert  into `sys_role_menu`(`role_id`,`menu_id`) values (0,0),(12,2017),(12,2022),(12,2024),(12,2025),(12,2026),(12,2027),(13,1),(13,102),(13,1013),(13,1014),(13,1015),(13,1016),(13,2017),(13,2018),(13,2019),(13,2021),(13,2022),(13,2023),(13,2024),(13,2025),(13,2026),(13,2027),(13,2028),(14,1),(14,102),(14,1013),(14,1014),(14,1015),(14,1016),(14,2023);

/*Table structure for table `sys_user` */

DROP TABLE IF EXISTS `sys_user`;

CREATE TABLE `sys_user` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `type` char(1) DEFAULT '0' COMMENT '用户类型：0代表普通用户，1代表管理员',
  `status` char(1) DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` varchar(64) DEFAULT NULL COMMENT '邮箱',
  `phonenumber` varchar(32) DEFAULT NULL COMMENT '手机号',
  `sex` char(1) DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `avatar` varchar(128) DEFAULT NULL COMMENT '头像',
  `create_by` bigint DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `del_flag` int DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14787164048667 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户表';

/*Data for the table `sys_user` */

insert  into `sys_user`(`id`,`user_name`,`nick_name`,`password`,`type`,`status`,`email`,`phonenumber`,`sex`,`avatar`,`create_by`,`create_time`,`update_by`,`update_time`,`del_flag`) values (1,'tune','tune','$2a$10$GveWXZzSH7GIPCLjyfqsUeYbOkoA.xBsAJTsJ4/New6yFi2rYhwcK','1','0','123@qq.com',NULL,NULL,NULL,-1,'2023-11-22 21:43:40',-1,'2023-11-22 21:43:40',0),(14787164048664,'wxx','wxx','$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy','0','0','23412332@qq.com','18888888888','1','',NULL,'2023-08-05 09:01:56',1,'2023-09-27 08:20:04',0),(14787164048665,'qqquege','千千阙歌','$2a$10$VFS8NExdGuoJ/3oPM7WHX.Q0XLlfEq/nQkqOcKZqeTnR9r5C4kwZi','0','0','tune2000@163.com','15800001111','0',NULL,1,'2023-09-27 07:55:01',1,'2023-09-27 08:20:12',0),(14787164048666,'GOO','灰色浮年','$2a$10$N2AKB5cz9CVJh8ZqeHnj2O71/A7k.5Y.g7IyXLIkO1QtMWhxhfjqq','0','0','1993@qq.com',NULL,'0',NULL,-1,'2023-12-27 12:42:13',NULL,'2023-12-27 16:36:10',0);

/*Table structure for table `sys_user_role` */

DROP TABLE IF EXISTS `sys_user_role`;

CREATE TABLE `sys_user_role` (
  `user_id` bigint NOT NULL COMMENT '用户ID',
  `role_id` bigint NOT NULL COMMENT '角色ID',
  PRIMARY KEY (`user_id`,`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3 COMMENT='用户和角色关联表';

/*Data for the table `sys_user_role` */

insert  into `sys_user_role`(`user_id`,`role_id`) values (1,1),(14787164048663,2),(14787164048664,12),(14787164048664,13);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
